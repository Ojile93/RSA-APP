# RSA-APP
RSA-APP DOCUMENTATION

The application which this documentation is written about will be called RSA App. RSA because the principles behind its encryption and decryption are based on RSA cryptographic math. This documentation will serve as guide illustrating how to use the application and the concept behind it operations .
The application broadly has three functionalities 1. Generation of RSA token, 2. Encrypting a message ,3. Decrypting an encrypted message.
1. Generation of RSA token: RSA token are three special numbers which are used to encrypt or decrypt a message . The keys are 1. Private key, 2. Public key. 3. Totient; (please note, the totient as widely used in RSA cryptography is the multiplicate of two prime numbers after deducting one from each of the prime numbers, but the totient as I will be mentioning in this documentation is the multiplicate of two prime numbers which is often refers to as semi-prime, my choice is just for simplicity) . The procedure adopted in generating these tokens are purely based on RSA math and will not be further discus in this guide. A careful look at the code base of this documentation will explain to you the processes and math behind it or still for further knowledge a google search can be of great help. To generate this token just click on the “Generate RSA tokens” from the Home Screen of the application, then click “Generate keys” a screen will open show casing your token details. These token are not specific or unique for an application user, Different tokens will always be generated if you go through this process once more. When you generate your token it is highly advised you keep them very safe; especially if you intend to encode a message with it; as per general practice, public key and totient are used for encrypting message while private key and totient are used for decrypting. Please be warned that the application does not stored or backup your keys, as such, will not be able to recover any if your tokens are lost.
2. Encrypting message: The second functionality of the application is encoding message such that even if the encoded message got expose the meaning of that message will remain unclear until you decode it with the appropriate corresponding private key and totient. This is very useful since many deal with so many platform that requires password and saving passwords directly in your email or writing it on a paper can be easily compromised if the integrity of your email or phone or the paper which you write passwords on are compromised. The encoded message can be stored anywhere without fear of making meaningful use of it if your store base got compromised. Message are encode this way “message (converted to ascii characters) raised to power of public key modulus totient” . For instance given the message “I love Naomi” the system will firstly convert the message to ascii characters using the inbuilt python ord() function, which will return a numerical representative of the message “I love Naomi” then loop through this numbers performing the RSA math on them, i.e message raised to power of public key modulus totient; the output will be string of numerical figures, this figures are your encoded message and need to be store anywhere that is easily accessible to you so that whenever you need the original message you bring it back to decode it. The procedure of doing this from the application is click “Encode message” from the Home Screen of the application, when the page open input your message, public key and and totient at the appropriate designated space and then click “submit”; if the tokens are appropriate a page will open displaying your encoded message copy the encoded message and save it anywhere. PLEASE BE REMINDED THAT, THE MACHINE DOES NOT STORE ENCODED MESSAGE THEREFORE CAN NOT RECOVER IT FOR YOU IF LOST, also be aware that encode message can only be unlock with the appropriate corresponding private key and totient alone, also don't clear the gap between the generated encoded message before saving, i.e if you get an encoded message of 2345, 6789 don't clean the gap by making it to be 23456789.
3. Decrypting message: Message as used in this instance means your cipher encoded message. This functionality enable you to decode an encrypted or encoded message to its original form, the message are decoded using this formular “message raised to power of private key modulus totient” then these results are converted to characters using the inbuilt python chr() function. To do this on the app, click “decode message” from the Home Screen of the Application, a page will open where fields will be available for you to impute your encoded cipher message, private key and totient, click on the “Submit” button, if your impute are okay, your real message will be display on the window that will open.
Note: Message can be either encoded with public key and totient or private key and totient; it is your choice, meanwhile note that if you encode your message with public key and totient you can only unlock it with the right private key and totient; also if you choose to encode your message with private key and totient then that message can only be unlock with public key and totient.
MATHEMATICALLY INSTANCE.
let us consider a simple example, to serve as guide to locking or unlocking message manually if the application for any reason is not available. Given a public key of 4801, private key 7489 and totient 281969 and a message “I love Naomi”, the machine firstly convert the message “I love Naomi” to its ascii representative, the ascii representation of “I” is 73 and will do same for the whole message, so the whole ascii translation of the message will be 73, 32, 108, 111, 118, 101, 32, 78, 97, 111, 109, 105; ( for the machine, the python inbuilt ord() function was used) after that, the machine encode the message for each of the ascii characters by during this mathematical operation, for the first message 'I' with ascii representative of '73' it will be 73^4801 %281969 which is 260655 where ^ = raised to power sign, % = modulus sign(NOT DIVISION SIGN), 4801 = public key, 281969 = Totient, if you perform same operation on each of the ascii represented message you will get 260655, 277829, 89972, 164631, 126649, 60131, 277829, 182861, 193435, 164631, 86939, 143538; this the cipher encoded representation of the message “I love Naomi “ . The only way to convert the message back to it original form is to do the same operation with the encoded message but switching public key with private key, so converting back you do this mathematical operation on each of the encoded cipher, 260655^7489%281969, then you convert the value to alphabet which in our case we used the python chr() function which is “I” if we do same operation on all the encoded message we will get the correct original message.
Limitation of the Machine.
1. The security of the cipher encoded message is heavily dependent on the totient value ability to be factorized . For easily mathematical operation and comprehension the machine uses very low number of bits computation which is not secure at all. Your totient should be heavily guided like your private key because a simple algorithm can factorize it. The ideal usage of RSA which allow for sharing of totient i.e factory use cases always use like 2048bits, while this machine user only around 16-18 bits
2. The speed of the operation is limited to the learnt of the message you want to encode or decode, it may take longer time to encode or decode very large file.

Your reviews are humbly welcome Here is the link to the apk on my Google drive https://drive.google.com/file/d/1-OD72aCbZy4Oeazg-or0bFnJtSOe_Xy2/view?usp=drivesdk

